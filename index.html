
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>TNM084 Project</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
		<!-- Bootstrap Core CSS -->
    	<!-- <link href="css/bootstrap.min.css" rel="stylesheet"> -->

    	<!-- för att starta en server >> terminal >> python -m SimpleHTTPServer -->

		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}

			#container {
			background: #fff;
			background-color: #fff;
		}

			#info {
				color:#000;
				position: absolute;
				top: 0px; width: 50%;
				padding: 5px;
			}

			a {
				color: red;
			}
		</style>

		<script src="//code.jquery.com/jquery-1.12.0.min.js"></script>
		<script type="text/javascript" src="js/dat.gui.js"></script>

		<!-- GUI -->
		<script type="text/javascript">
		

		GuiContent = function() {
			this.Radius = 2.0;
			this.FogOneOrTwo = false;
			this.Mystery = false;
			this.NoiseFrequency = 0.1;
			this.SimplexNoise = true;
			this.PerlinNoise = false;
		};

		var gui_content;

		window.onload = function() {
			var obj = {
				Name: "Emma Forsling Parborg",
				num: 28
			};

			gui_content = new GuiContent();
			var gui = new dat.GUI();

			gui.add(obj,"Name");
			var f1 = gui.addFolder('Change Noise');
			f1.add(gui_content, 'NoiseFrequency', 0.0, 1.0);

			var f2 = gui.addFolder('Fog shape');
			f2.add(gui_content, 'Radius', 2.0, 20.0);
			f2.add(gui_content, 'FogOneOrTwo');

			var f3 = gui.addFolder('Other');
			f3.add(gui_content, 'Mystery');


		};
		</script>
		
	</head>

	<body>
		
		<!-- <div class="row"> -->
            <!-- <div class="col-lg-3 text-center"> </div> -->
			<!-- <div class="col-lg-6 text-center">  -->
		<div id="container">
			<!-- Here some cool stuff will appear! -->
		</div>
		<!-- <header> -->
			<h1> Find the secret message! </h1>
		<!-- </header> -->
			<!-- </div> -->
			<!-- <div class="col-lg-3 text-center"> </div> -->
		<!-- </div> -->
		<!-- Shaders -->
		<script type="x-shader/x-vertex" id="vertexshader">
			// switch on high precision floats
			#ifdef GL_ES
			precision highp float;
			#endif
			
			uniform float time;
			uniform float planeWidth;
			uniform float planeHeight;
			uniform float seaDepth;
			uniform float skyHeight;
			uniform float amplGain;
			uniform vec3 cameraPosWorldSpace;

			uniform vec3 sunPosition;			

			// varying vec3 interpolatedNormalViewSpace;
			varying vec3 interpolatedNormalWorldSpace;
			// varying vec3 lightDirectionViewSpace;
			varying vec4 fragWorldPos;
			varying vec4 lightPositionWorldSpace;
			vec3 randVector;

			// varying mat4 test;
			void main()
			{		
				// Calculating new displaced position
				vec3 displacedPosition = position.xyz + normal;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(displacedPosition, 1.0);

				// Forward difference sample points
				float h = 0.1;
				vec3 forwardPointX = vec3(position.x + h, position.y, position.z);
				vec3 forwardPointY = vec3(position.x, position.y + h, position.z);

				// Displacement
				float forwardPointXDisp = 1.0;
				float forwardPointYDisp = 1.0;
				vec3 forwardPointXDispPos = forwardPointX + forwardPointXDisp * normal;
				vec3 forwardPointYDispPos = forwardPointY + forwardPointYDisp * normal;

				// Difference vectors
				vec3 diffVectorX = normalize(displacedPosition - forwardPointXDispPos);
				vec3 diffVectorY = normalize(displacedPosition - forwardPointYDispPos);

				// New normal
				vec3 newNormal = normalize(cross(diffVectorX, diffVectorY));

				// test = mat4(viewMatrix * projectionMatrix);
				
				// Transformation of 'varyings'
				interpolatedNormalWorldSpace = normalize(mat3(modelMatrix) * newNormal);
				//interpolatedNormalViewSpace = normalize(mat3(modelViewMatrix) * newNormal);
				// lightDirectionViewSpace = normalize(mat3(viewMatrix) * normalize(vec3(0.0, 1.0, 1.0)));
				lightPositionWorldSpace = vec4(sunPosition.x, sunPosition.y, sunPosition.z, 1.0);
				fragWorldPos = vec4(displacedPosition, 1.0) * modelMatrix; // gl_Position * modelMatrix;
			}
			
		</script>
		
		<script type="x-shader/x-vertex" id="vertexshader-walls">
			#ifdef GL_ES
			precision highp float;
			#endif
			
			

			void main() {
			  
			  
			  gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader-walls">
			#ifdef GL_ES
			precision highp float;
			#endif

			uniform int wall;

			void main()
			{
				vec4 diffuseLightColor = vec4(0.0, 0.0, 0.0, 1.0);
				//Different colors for
				if(wall == 0){									
					diffuseLightColor = vec4(0.3, 0.3, 0.3, 1.0);	// walls
				} else if(wall == 1){							
					diffuseLightColor = vec4(0.5, 0.5, 0.5, 1.0);	// floor, ceiling
				} else {
					diffuseLightColor = vec4(0.0,0.0,0.0, 1.0);		// door, windowframes
				}

				gl_FragColor = diffuseLightColor;
				
			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
		
		#ifdef GL_ES
		precision highp float;
		#endif

		/* NOISE */

		vec3 mod289(vec3 x) {
			return x - floor(x * (1.0 / 289.0)) * 289.0;
		}

		vec4 mod289(vec4 x) {
			return x - floor(x * (1.0 / 289.0)) * 289.0;
		}

		vec4 permute(vec4 x) {
			return mod289(((x*34.0)+1.0)*x);
		}

		vec4 taylorInvSqrt(vec4 r)
		{
			return 1.79284291400159 - 0.85373472095314 * r;
		}

		vec3 fade(vec3 t) {
			return t*t*t*(t*(t*6.0-15.0)+10.0);
		}


		// Classic Perlin noise
		float cnoise(vec3 P)
		{
		  vec3 Pi0 = floor(P); // Integer part for indexing
		  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
		  Pi0 = mod289(Pi0);
		  Pi1 = mod289(Pi1);
		  vec3 Pf0 = fract(P); // Fractional part for interpolation
		  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;

		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);

		  vec4 gx0 = ixy0 * (1.0 / 7.0);
		  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

		  vec4 gx1 = ixy1 * (1.0 / 7.0);
		  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;

		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);

		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
		  return 2.2 * n_xyz;
		}

			

		float snoise(vec3 v)
		{
			const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
			const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

			// First corner
			vec3 i  = floor(v + dot(v, C.yyy) );
			vec3 x0 =   v - i + dot(i, C.xxx) ;

			// Other corners
			vec3 g = step(x0.yzx, x0.xyz);
			vec3 l = 1.0 - g;
			vec3 i1 = min( g.xyz, l.zxy );
			vec3 i2 = max( g.xyz, l.zxy );

			//   x0 = x0 - 0.0 + 0.0 * C.xxx;
			//   x1 = x0 - i1  + 1.0 * C.xxx;
			//   x2 = x0 - i2  + 2.0 * C.xxx;
			//   x3 = x0 - 1.0 + 3.0 * C.xxx;
			vec3 x1 = x0 - i1 + C.xxx;
			vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
			vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

			// Permutations
			i = mod289(i);
			vec4 p = permute( permute( permute(
			         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
			       + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
			       + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

			// Gradiusnts: 7x7 points over a square, mapped onto an octahedron.
			// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
			float n_ = 0.142857142857; // 1.0/7.0
			vec3  ns = n_ * D.wyz - D.xzx;

			vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

			vec4 x_ = floor(j * ns.z);
			vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

			vec4 x = x_ *ns.x + ns.yyyy;
			vec4 y = y_ *ns.x + ns.yyyy;
			vec4 h = 1.0 - abs(x) - abs(y);

			vec4 b0 = vec4( x.xy, y.xy );
			vec4 b1 = vec4( x.zw, y.zw );

			//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
			//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
			vec4 s0 = floor(b0)*2.0 + 1.0;
			vec4 s1 = floor(b1)*2.0 + 1.0;
			vec4 sh = -step(h, vec4(0.0));

			vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
			vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

			vec3 p0 = vec3(a0.xy,h.x);
			vec3 p1 = vec3(a0.zw,h.y);
			vec3 p2 = vec3(a1.xy,h.z);
			vec3 p3 = vec3(a1.zw,h.w);

			//Normalise gradiusnts
			vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
			p0 *= norm.x;
			p1 *= norm.y;
			p2 *= norm.z;
			p3 *= norm.w;

			// Mix final noise value
			vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
			m = m * m;
			return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
			                            dot(p2,x2), dot(p3,x3) ) );
		}

		/* NOISE ENDS HERE */

		
		uniform float time;
		uniform float seaDepth;

		uniform float skyHeight;
		
		uniform float planeWidth;
		uniform float planeHeight;

		uniform float window_height;
		uniform float window_width;
		
		uniform vec3 cameraPosWorldSpace;
		
		uniform sampler2D landscape_Texture;
		uniform sampler2D hidden_Texture;		// hidden message texture
		uniform samplerCube cubeMap;			// landscape texture background
		uniform samplerCube cubeMapBlurr;			// landscape texture background

		uniform vec2 mousePosition;				// world coordinates
		uniform float radius;					// radius of the fog

		uniform vec3 mousePositionWorldSpace;
		uniform int mystery_function;
		uniform float noise_frequency;

		varying vec3 interpolatedNormalWorldSpace;
		varying vec4 fragWorldPos;
		varying vec4 lightPositionWorldSpace;
	
		vec3 viewDirectionWorldSpace;
		vec4 refractionColor;
		vec4 hiddenMessageColor;
		vec4 blurryColor;

		float surface3( vec3 coord ) {

			float n = 0.0;

			n += 0.5 * abs( snoise( coord ) );
			n += 0.25 * abs( snoise( coord * 2.0 ) );
			n += 0.125 * abs( snoise( coord * 4.0 ) );
			n += 0.0625 * abs( snoise( coord * 8.0 ) );

			return n;

		}


		vec4 mysteryFunction(vec3 pos){
			float frequency = 0.2;
			float fogValue = (cnoise(pos * frequency) + 1.0) / 2.0;				// [0,1]

			// Fog color
			const vec3 fogColor = vec3(0.7, 0.7,0.7);
			const float FogDensity = 0.05;
			float dist = 0.0;
			dist = (gl_FragCoord.z / gl_FragCoord.w);

			float noisy = surface3(vec3(refractionColor));
			float check = surface3(vec3(refractionColor));
			if(noisy < check)
				noisy = 1.0;

			float fogFactor = 0.0;
			fogFactor = 1.0 /exp( dist);
   			fogFactor = clamp( fogFactor, 0.0, 1.0 );

   			vec4 fogColorMix = vec4(0.0,0.0,0.0,0.0);
   			fogColorMix = (hiddenMessageColor.x < 0.7 || hiddenMessageColor.y < 0.7 || hiddenMessageColor.z < 0.7) 	?
   			 				( vec4( mix( fogColor, vec3(blurryColor), 1.0 - fogFactor ), 1.0 ) )				: 
   							( vec4( mix( fogColor, vec3(hiddenMessageColor), 1.0 - fogFactor ), 1.0 ) );

			return ((1.0 - fogValue) * fogColorMix + fogValue * blurryColor)*noisy;
		}

		/* Function fog() */
		vec4 fog(vec3 pos)
		{
			float frequency = 0.2;
			float fogValue = (cnoise(pos * frequency) + 1.0) / 2.0;				// [0,1]

			// Fog color
			const vec3 fogColor = vec3(0.7, 0.7,0.7);
			const float FogDensity = 0.05;
			float dist = 0.0;
			dist = (gl_FragCoord.z / gl_FragCoord.w);

			float noisy = surface3(vec3(refractionColor));
			float check = surface3(vec3(refractionColor));
			if(noisy < check)
				noisy = 1.0;

			float fogFactor = 0.0;
			fogFactor = 1.0 /exp( dist);
   			fogFactor = clamp( fogFactor, 0.0, 1.0 );

   			vec4 fogColorMix = vec4(0.0,0.0,0.0,0.0); // =  vec4(mix(fogColor, vec3(hiddenMessageColor), 1.0 - fogFactor ), 1.0);
   								//vec4(1.0,0.0,0.0,0.0);
   								//vec4(mix(fogColor, vec3(refractionColor), 1.0 - fogFactor ),1.0);
   			
   			// fogColorMix = vec4(mix(fogColor, vec3(blurryColor), fogFactor ), 1.0 );


   			fogColorMix = (hiddenMessageColor.x < 0.7 || hiddenMessageColor.y < 0.7 || hiddenMessageColor.z < 0.7) 	?
   			 				( vec4( mix( fogColor, vec3(blurryColor), 1.0 - fogFactor ), 1.0 ) )				: 
   							( vec4( mix( mix( vec3(blurryColor) , vec3(hiddenMessageColor), 1.0 - fogFactor), fogColor, 1.0 - fogColor ), 1.0 ) );

			return (1.0 - fogValue) * fogColorMix + fogValue * blurryColor;
		}

		/* Function noFog() will only display the background cube map since no fog is on it */
		vec4 noFog()
		{
			return textureCube(cubeMap, viewDirectionWorldSpace);
		}


	
		void main()
		{
			vec3 diffuseColor = vec3(0.1, 0.1, 0.1);
			vec3 specularColor = vec3(1.0, 1.0, 1.0);
			viewDirectionWorldSpace = -normalize(cameraPosWorldSpace - fragWorldPos.xyz);
			vec3 lightDirectionWorldSpace = normalize(fragWorldPos.xyz - lightPositionWorldSpace.xyz);

			

			/** ====================================== **/ 
			/*				Diffuse lighting 			*/ 
			/** ====================================== **/ 
			float diffuseLighting = max(0.0, dot(vec3(0.0, 0.0, 1.0), interpolatedNormalWorldSpace));		// R = dot(I, N)
			diffuseLighting = pow(diffuseLighting, 10.0);

			/** ====================================== **/ 
			/*				Specular lighting 			*/ 
			/** ====================================== **/ 
			
			// Compute reflection direction vector (Blinn-phong)
			float specularPower = 256.0;
			vec3 reflectionWorldSpace = 2.0 * interpolatedNormalWorldSpace * dot(interpolatedNormalWorldSpace, lightDirectionWorldSpace) - (lightDirectionWorldSpace);
			float specularLighting = pow(max(0.0, dot(reflectionWorldSpace, viewDirectionWorldSpace)), specularPower);

			/** ====================================== **/ 
			/*				Hidden Message 				*/ 
			/** ====================================== **/ 
			// Get normalized object coordinates [0,1]
			float px = fragWorldPos.x / (planeWidth/3.0) + 0.5;
			float py = fragWorldPos.y / (planeHeight/3.0) + 0.5;

			// Create 2D uv coordinates
			vec2 texCoord2D_hiddenMessage = vec2(px, py);

			// Sample hidden texture texture at these coordinates
			hiddenMessageColor = texture2D(hidden_Texture, texCoord2D_hiddenMessage);	// hidden texture

			/** ====================================== **/ 
			/*				Blurry Texture 			*/ 
			/** ====================================== **/			
			// Get normalized object coordinates
			px = fragWorldPos.x / (planeWidth/3.0) + 0.5;
			py = fragWorldPos.y / (planeHeight/3.0) + 0.5;

			// Create 2D uv coordinates
			vec2 texCoord2D_blurry = vec2(px, py);
			blurryColor = textureCube(cubeMapBlurr, viewDirectionWorldSpace);			//landscape texture


			/** ====================================== **/ 
			/*					Refraction 				*/ 
			/** ====================================== **/ 
			// // Compute refraction direction vector
			// vec3 refractionDirWorldSpace = refract(viewDirectionWorldSpace, interpolatedNormalWorldSpace, 0.75);

			// // Compute angle between refraction and 'down vector'
			// float cos_alpha = dot(vec3(0.0, 0.0, -1.0), refractionDirWorldSpace);
			// float alpha = acos(cos_alpha);

			// // Compute sampling offset
			// float offset_x = tan(alpha) * seaDepth * refractionDirWorldSpace.x;
			// float offset_y = tan(alpha) * seaDepth * refractionDirWorldSpace.y;

			// // Compute distance traveled (hypothenuse)
			// float refractionDist = cos_alpha / seaDepth;

			/** ====================================== **/ 
			/*		Refraction color from the cubeMap 	*/ 
			/** ====================================== **/
			refractionColor = textureCube(cubeMap, viewDirectionWorldSpace);

			/** ====================================== **/ 
			/*		Create Fog shape x^2 + y^2 = r^2 	*/ 
			/** ====================================== **/
			// Extract the mousePosition 		
			vec3 currentMousePosition = vec3(6666.0,6666.0,0.0);
			if(mousePosition != vec2(6666.0,6666.0)){			// If (uniform) mouseposition is on the glass window		
				currentMousePosition = mousePositionWorldSpace;	// Set the currentMousePosition to mouseposition
			}

			// Calculate the radius for a perfect circle, with the currentMousePosition as the center/origin of the circle.
			float distanceToMouseFromFragmentPosition = sqrt( pow(fragWorldPos.x - currentMousePosition.x, 2.0) + 
												pow(fragWorldPos.y - currentMousePosition.y, 2.0) );
			
			// Create some noise
			float frequency2 = 0.1;
			float tempNoise2 = snoise(fragWorldPos.xyz * noise_frequency) + 1.5;		//[]	
			float tempNoise3 = surface3(fragWorldPos.xyz * frequency2);														// myror
			// float tempNoise3 = pnoise(fragWorldPos, vec3(0, 0 , time)) * 1.0;

			float padding = 0.2;
			float fogOutline = radius * tempNoise2;// + tempNoise2;			
			// Add noise to the actual radius and compare it with the computed radius, 
				// and determine if fog or no fog shall be created
			// gl_FragColor = (distanceToMouseFromFragmentPosition <= fogOutline) ? 
								// ( fog(fragWorldPos.xyz) ) : 
									// ( (distanceToMouseFromFragmentPosition <= fogOutline + padding) ? 
										// (fogTheOutline(fragWorldPos.xyz) ) : ( noFog() ) );
			
			
			
			float smoothy = smoothstep(0.0, fogOutline, distanceToMouseFromFragmentPosition);		// if returns 1.0 then no fog, if 0.0 mycket fog
			
			gl_FragColor = (mystery_function == 0) ?
							(	(distanceToMouseFromFragmentPosition < fogOutline /*&& distanceToMouseFromFragmentPosition > 0.0*/) ? (1.0 - smoothy) * fog(fragWorldPos.xyz) + smoothy * noFog() : noFog() ) :
							( 	(distanceToMouseFromFragmentPosition < fogOutline && distanceToMouseFromFragmentPosition > 0.0) ? (1.0 - smoothy) * mysteryFunction(fragWorldPos.xyz) : noFog()	);



			/* Testar att göra fog /color */
			// vec3 lightColor = vec3(diffuseColor * diffuseLighting + specularColor * specularLighting);

			// //vec3 lightColor = vec3(diffuseColor * diffuseLighting + specularColor * specularLighting);
			
 	
			/* slut på test*/

			
			
			
		}
		</script>
		<!-- End Shaders -->
		
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/controls/TrackballControls.js"></script>
		<script src="js/FlyControls.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="myScene.js"></script>

		<!-- jQuery -->
    	<!-- // <script src="js/jquery.js"></script> -->
		<!-- Bootstrap Core JavaScript -->
    	<!-- // <script src="js/bootstrap.min.js"></script> -->

	</body>
</html>
